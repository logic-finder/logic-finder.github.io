<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>보수(補數)에 대해서</title>
    <style>
      div#content {
        border: 1px solid black;
        width: 200px;
      }

      div#content div#title {
        text-align: center;
      }

      table {
        border: 1px solid black;
      }

      table td {
        border: 1px solid black;
      }

      pre {
        background-color: lightgray;
      }
    </style>
  </head>
  <body>
    <a href="../index.html">return to home</a>
    <p>이것저것 찾아보던 중 궁금해 번역하였다. 중요한 단락에 별표를 쳤다. 솔직히 어려워서 대부분 이해가 안 됐다. 그리고 번역하는 건 너무 어려운 것 같다.</p>
    <p>원 글 출처(original document): <a href="https://en.wikipedia.org/wiki/Method_of_complements">영어 위키피디아 Method of complements 문서</a></p>
    <p>번역일자: 22년 1월 24일 ~ 22년 1월 25일</p>
    <p>※ 이 번역은 비공식적입니다. 개인 공부용입니다. / This translation is unofficial; for the sake of personal study.</p>
    <hr>
    <p>관련 글</p>
    <ol>
      <li><a href="https://en.wikipedia.org/wiki/Ones%27_complement">1의 보수</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Two%27s_complement">2의 보수</a></li>
    </ol>
    <hr>
    <h1>★보수법</h1>
    <section>
      <p>수학과 컴퓨팅 분야에서, 보수법(method of complement)이란 대칭적인 범위의 양의 정수와 음의 정수를 특정한 방법으로 부호화(encode)하기 위한 기법인데, 그 방법이란 범위 내의 모든 양의 정수와 음의 정수가 덧셈에 대해 같은 알고리즘 (하드웨어) 을 사용할 수 있게 하는 것이다. 주어진 수의 자리에 대해, 수의 가능한 표현의 절반은 양수를 부호화하고, 나머지 절반은 양수들 각각의 additive inverse(※)를 나타낸다. 서로 additive inverse인 수의 쌍을 보수(complement)라고 한다. 따라서 어떠한 수의 뺄셈은 그 수의 보수를 더함으로써 구현된다. 어떠한 수의 부호를 변경하는 것은 이 수의 보수를 생성함에 의해 부호화되는데, 이는 아주 간단하고 효율적인 알고리즘에 의해 이루어질 수 있다. 이 기법은 기계 계산기에서 일반적으로 사용되었고 여전히 현대의 컴퓨터에서 사용되고 있다. 기수 보수(radix complement)의 일반적인 개념 (아래에서 서술됨) 은 또한 정수론에서 가치가 있는데, 이를테면 Midy의 이론에서와 같은 것이 있다.</p>
      <p>※ additive inverse: 덧셈에 관한 역원(逆元): 어떤 수에 더해서 그 값이 0이 되게 하는 실수. (출처: 네이버 영어사전)</p>
      <p>역자주: 만약 a = 2라면 a의 additive inverse는 정의에 의해 -2가 된다. 따라서, 어떠한 수의 뺄셈, 예를 들어 3 - 2라면, 이는 다음과 같이 구현될 수 있음을 이야기하는 것 같다: 3 + (-2).</p>
      <br>
      <p>10진법 표현에서 주어진 수의 「9들의 보수」(nines' complement)는 각 숫자를 '9 - 그 숫자'를 한 것으로 대체함에 의해 형성된다. 십진법 수 y (감수=빼는 수)를 다른 수 x (피감수=빼짐을 당하는 수)에서 빼기 위해서는 두 가지 방법이 사용될 수 있다:</p>
      <br>
      <p>첫번째 방법에서는 x의 9들의 보수가 y에 더해진다. 그리고 나서, 얻어진 결과의 9들의 보수가 형성되어 원하는 결과를 생성해낸다.</p>
      <br>
      <p>두번째 방법에서는 y의 9들의 보수가 x에 더해지고 1이 그 합에 더해진다. 결과의 맨 왼쪽 숫자 '1' 은 그리고 나서 폐기된다. 맨 왼쪽의 '1' 을 폐기하는 것은 특히 고정된 수의 숫자를 사용하는 계산기나 컴퓨터에서 편리하다. '1'이 갈 곳이 없으므로 '1'은 단순히 계산 과정 중에서 잃어버려진다. 9들의 보수 더하기 1은 「10의 보수」로 알려져 있다.</p>
      <br>
      <p>보수법은 다른 기수로 확장될 수 있다; 특히, 보수법은 대부분의 디지털 컴퓨터에서 사용되어 뺄셈을 수행하고, 기수 2의 음수나 이진 계산을 표현하고, 계산에서의 언더플로우나 오버플로우를 시험한다.</p>
      <div id="content">
        <div id="title">목차</div>
        <ol>
          <li><a href="#보수">★보수</a></li>
          <li><a href="#10진법 예제">★10진법 예제</a>
            <ol>
              <li><a href="#첫번째 방법">★첫번째 방법</a></li>
              <li><a href="#두번째 방법">★두번째 방법</a></li>
              <li><a href="#수의 규모">★수의 규모</a></li>
            </ol>
          </li>
          <li><a href="#이진 방법">★이진 방법</a></li>
          <li><a href="#음수 표현">★음수 표현</a></li>
          <li><a href="#실용적 사용">실용적 사용</a>
            <ol>
              <li><a href="#컴퓨터에서">컴퓨터에서</a></li>
              <li><a href="#직접 사용하기">직접 사용하기</a></li>
            </ol>
          </li>
          <li><a href="#초등학교 교육에서">초등학교 교육에서</a></li>
        </ol>
      </div>
    </section>
    <section>
      <h2 id="보수">★보수</h2>
      <p>'기수(※) b'의 'n 자리' 수 'y'의 「기수 보수」(radix complement)는, 정의에 의해, b<sup>n</sup> - y이다. 기수 보수는 감기수 보수(diminished radix complement)에 1을 더함으로써 가장 쉽게 얻어지는데, 감기수 보수는 (b<sup>n</sup> - 1) - y이다. (b<sup>n</sup> - 1)은 n번 반복된 숫자 b - 1이므로 [이유: b<sup>n</sup> - 1 = (b - 1)(b<sup>n-1</sup> + b<sup>n-2</sup> + ... + b + 1) = (b-1)b<sup>n-1</sup> + ... + (b - 1). 등비급수 공식을 참고하시오], 어떤 수의 감기수 보수는 각 자리를 b - 1에 대해 보완(complement)함으로써 찾아질 수 있다 (즉, y의 각 자리를 b - 1 로부터 빼는 것).</p>
      <p>역자주: 즉 숫자 21이 있으면--10진법이니까 기수는 10, 2자리이므로 자릿수는 2--이것의 기수 보수는 100 - 21 = 79이고 감기수 보수는 99 - 21 = 78. 2자리이므로 9가 2번 반복됨.</p>
      <p>※ 기수: 수를 나타내는 데 기초가 되는 수. 십진법에서는 0에서 9까지의 정수를 이른다. (출처: 네이버 국어사전)</p>
      <p>※ diminished radix complement를 영어사전에 검색해보니 밑빼기 1 보수라고 하는데, 이게 감기수 보수와 동일한지는 모르겠다. (밑이 만약 base를 의미하는 거라면, 기수, 진법이라는 의미에서 base와 radix는 동일한 의미이므로 기수 빼기 1, 즉 10진법이라면 10-1=9이므로 감기수 보수와 동일한 단어인 듯하다) 일단 국어사전과 일본어 위키피디아에서는 감기수 보수라는 말을 사용하고 있다.</p>
      <br>
      <p>x에서 y를 빼는 것은 다음과 같이 수행될 수 있다. x의 감기수 보수를 y에 더하는 것은 b<sup>n</sup> - 1 - x + y 또는 b<sup>n</sup> - 1 - (x - y) 의 값을 결과로 낳는데 이는 「x - y의 감기수 보수」이다. 「x - y의 감기수 보수」의 감기수 보수가 x - y의 값이다. 다른 방법으로, y의 기수 보수를 x에 더하는 것은 x + b<sup>n</sup> - y 또는 x - y + b<sup>n</sup> 값을 결과로 낳는다. y ≤ x를 가정할 때, 결과는 항상 b<sup>n</sup> 보다 크거나 같을 것이고 맨 처음의 '1' 을 폐기하는 것은 b<sup>n</sup> 을 빼는 것과 같으며, 이는 x - y + b<sup>n</sup> - b<sup>n</sup> 또는 단지 x - y의 결과를 낳는데, 이는 원하던 결과이다.</p>
      <p>역자주: 피감수 x = 33, 감수 y = 21이라고 하자. 처음 방법) x의 감기수보수 66 + 감수 21 = 87. 87의 감기수보수 = 12. 33-21 = 12. 두번째 방법) y의 기수보수 79 + 피감수 33 = 112. 112 - 100 = 12. 33-21 = 12.</p>
      <br>
      <p>십진법 숫자 체계에서, 기수 보수는 「10의 보수」 (ten's ~) 라고 불리고 감기수 보수는 「9들의 보수」 (nines' ~ ) 라고 불린다. 이진법에서, 기수 보수는 「2의 보수」 (two's ~) 라고 불리고 감기수 보수는 「1들의 보수」 (ones' ~ ) 라고 불린다. 다른 기수에서의 네이밍도 이와 비슷하다. 몇몇 사람들은, 대표적으로 Donald Knuth (주: 미국의 컴퓨터 과학자) 는, 어포스트로피(')의 위치를 사용하여 기수 보수와 감기수 보수를 구별하는 것을 추천한다. 이 사용법에서, '4의 보수' (four's ~) 는 기수 4에서의 숫자의 기수 보수를 의미하는 반면 '4들의 보수' (fours' ~ ) 는 기수 5에서의 숫자의 감기수 보수이다. 그러나, 이 구분은 기수가 분명할 때 (거의 항상 그럼) 중요하지 않으며 어포스트로피 위치의 미묘한 차이는 일반적인 관습이 아니다. 대부분의 필자들은 1의 보수 (one's ~) 와 9의 보수 (nine's ~) 를 사용하고, 많은 스타일 매뉴얼들은 어포스트로피를 생략하며, '1들 보수' (ones ~) 와 '9들 보수' (nines ~) 를 추천한다.</p>
    </section>
    <section>
      <h2 id="10진법 예제">★10진법 예제</h2>
      <p>10진법 숫자의 「9들의 보수」는 자신에 더해져서 반드시 9를 산출해내는 수를 말한다. 3의 보수는 6이고, 7의 보수는 2인 식이다. 아래의 표를 참고하라. 큰 수의 9들의 보수를 만들기 위해서는, 각 숫자는 자신의 9들의 보수에 의해 대체되어야 한다.</p>
      <table>
        <tr>
          <td>숫자</td>
          <td>9들의 보수</td>
        </tr>
        <tr>
          <td>0</td>
          <td>9</td>
        </tr>
        <tr>
          <td>1</td>
          <td>8</td>
        </tr>
        <tr>
          <td>2</td>
          <td>7</td>
        </tr>
        <tr>
          <td>3</td>
          <td>6</td>
        </tr>
        <tr>
          <td>4</td>
          <td>5</td>
        </tr>
        <tr>
          <td>5</td>
          <td>4</td>
        </tr>
        <tr>
          <td>6</td>
          <td>3</td>
        </tr>
        <tr>
          <td>7</td>
          <td>2</td>
        </tr>
        <tr>
          <td>8</td>
          <td>1</td>
        </tr>
        <tr>
          <td>9</td>
          <td>0</td>
        </tr>
      </table>
      <p>아래의 뺄셈 문제를 고려해 보라:</p>
      <pre>

    873  [x, 피감수]
  - 218  [y, 감수]
      </pre>
      <h3 id="첫번째 방법">★첫번째 방법</h3>
      <p>우리는 피감수 873의 9들의 보수를 계산한다. 계산된 수를 감수 218에 더한다. 그리고 나서 결과의 9들의 보수를 계산한다.</p>
      <pre>

    126  [x의 9들의 보수 = 999 - x]
  + 218  [y, 감수]
      </pre>
      <p>결과는</p>
      <pre>

  344  [999 - x + y]
      </pre>
      <p>이제 결과의 9들의 보수를 계산한다.</p>
      <pre>

  344  [결과]
  655  [344의 9들의 보수 = 999 - (999 - x + y) = x - y이며, 이는 옳은 답이다.]
      </pre>
      <h3 id="두번째 방법">★두번째 방법</h3>
      <p>218의 9들의 보수를 계산하는데, 그 값은 781이다. 왜냐하면 218은 길이가 3자리이므로, 이것은 218을 999에서 빼는 것과 같기 때문이다.</p>
      <p>다음으로, x와 y의 9들의 보수의 합이 취해진다:</p>
      <pre>

    873  [x]
  + 781  [y의 9들의 보수 = 999 - y]
      </pre>
      <p>결과는</p>
      <pre>

  1654  [999 + x - y]
      </pre>
      <p>맨 앞의 "1" 숫자는 그리고 나서 탈락되므로, 654의 값이 나온다.</p>
      <pre>

    1654
  - 1000  [-(999 + 1)]
      </pre>
      <p>결과는</p>
      <pre>

  654  [x - y - 1]
      </pre>
      <p>이것은 아직 옳지 않다. 우리는 근본적으로 첫번째 단계의 등식에 999를 더했기 때문이다. 그리고 나서 우리는 우리가 위의 결과 1654에서 맨 앞의 1을 탈락시킬 때 1000을 제거하였다. 이는 따라서 우리가 얻은 답 (654) 을 올바른 답 (x - y) 보다 하나 작게 만든다. 이것을 고치기 위해, 우리는 반드시 1을 우리의 답에 더해주어야만 한다.</p>
      <pre>

    654
  +   1
      </pre>
      <p>결과는</p>
      <pre>

  655  [x - y]
      </pre>
      <p>1을 더하는 것은 655의 값을 가져다 주며, 이는 우리의 원래 뺄셈 문제의 올바른 답이다. 만약 우리가 첫번째 단계에서 y의 10의 보수를 취했다면 우리는 1을 더하는 마지막 단계를 생략할 수도 있었을 것이다.</p>
      <h3 id="수의 규모">★수의 규모</h3>
      <p>다음의 예제에서 뺄셈의 결과는 x보다 적은 자릿수를 가지고 있다.</p>
      <pre>

    123410  [x, 피감수]
  - 123401  [y, 감수]
      </pre>
      <p>첫번째 방법을 사용하여, x의 9들의 보수와 y의 합은 수식으로 아래와 같으며</p>
      <pre>

    876589  [x의 9들의 보수]
  + 123401  [y]
      </pre>
      <p>그 결과는</p>
      <pre>

  999990
      </pre>
      <p>999990의 9들의 보수는 000009이다. 앞의 0들을 제거하는 것은 9를 가져다 주고 이는 원하던 결과이다.</p>
      <p>만약 감수 y가 피감수 x보다 적은 자릿수를 가지고 있다면, 두번째 방법에서 앞서는 0들은 반드시 더해져야만 한다. 이 0들은 보수가 취해졌을 때 앞서는 9들이 된다. 예를 들자면:</p>
      <pre>

    48032  [x]
  -   391  [y]
      </pre>
      <p>이는 아래와 같이 재작성될 수 있고</p>
      <pre>

    48032  [x]
  - 00391  [앞서는 0들을 가지고 있는 y]
      </pre>
      <p>00391을 자신의 9들의 보수로 대체하고 1을 더하는 것은 합을 생성해 낸다:</p>
      <pre>

    48032  [x]
  + 99608  [y의 9들의 보수]
  +     1
      </pre>
      <p>결과는</p>
      <pre>

  147641
      </pre>
      <p>앞서는 "1" 을 탈락시키는 것은 옳은 답인 47641을 가져다 준다.</p>
    </section>
    <section>
      <h2 id="이진 방법">★이진 방법</h2>
      <p>보수법은 특히 이진 (기수 2) 에서 유용한데, 그 이유는 1들의 보수가 각 비트를 반전시킴으로써 아주 쉽게 얻어지기 때문이다 ('0' 을 '1' 로 바꾸고 그 반대도 같음). 1을 더해 2의 보수를 얻는 것은 최하위 비트에 carry를 시뮬레이팅함으로써 얻어질 수 있다. 예를 들자면:</p>
      <p>※ carry (올림?): 덧셈할 때 윗 자리로 올라가는 것으로 추측됨. 9+7=16에서 1이 위로 올라감</p>
      <pre>

    0110 0100  [x, 십진법 100]
  - 0001 0110  [y, 십진법  22]
      </pre>
      <p>위 수식은 아래의 합이 된다:</p>
      <pre>

    0110 0100  [x]
  + 1110 1001  [y의 1들의 보수 = 1111 1111 - y]
  +         1  [2의 보수를 얻기 위해서 = 1 0000 0000 - y] // 역자주: 1111 1111 에 1을 더하면 carry가 8번 발생해 1 0000 0000 이 되는 것으로 생각됨.
  ===========
   10100 1110  [x + 1 0000 0000 - y]
      </pre>
      <p>맨 앞의 "1" 을 탈락시키는 것은 답을 가져다 준다: 0100 1110 (십진법 78)</p>
    </section>
    <section>
      <h2 id="음수 표현">★음수 표현</h2>
      <p><i>메인 문서: <a href="https://en.wikipedia.org/wiki/Signed_number_representations">부호 있는 수의 표현</a></i></p>
      <p>보수법은 보통 피연산자(operand)가 양수이고 y ≤ x인데, 이 주어진 논리적 제약은 임의의 정수를 더하고 빼는 것은 보통 부호를 비교하고, 두 개를 더하거나 작은 것을 큰 것으로부터 빼고, 올바른 부호를 가진 결과를 산출해 낸다고 가정한다.</p>
      <p>※ 피연산자(被演算子) 또는 오퍼랜드(operand)는 수학에서 연산자의 연산의 대상이다. (출처: 한국어 위키피디아)</p>
      <p>만약 x < y 일 경우 무슨 일이 일어나는지 살펴보자. 이 경우, x - y + b<sup>n</sup> 이 b<sup>n</sup> 보다 작을 것이므로 덧셈 이후에 지울 숫자 "1" 은 없을 것이다. 예를 들어, (십진법에서):</p>
      <pre>

    185  [x]
  - 329  [y]
      </pre>
      <p>y를 보완하고 더하는 것은 아래의 수식과 같다:</p>
      <pre>

    185  [x]
  + 670  [y의 9들의 보수]
  +   1
      </pre>
      <p>결과는</p>
      <pre>

  856
      </pre>
      <p>이 부분에서, b<sup>n</sup> (이 경우 1000) 을 뺌으로써 계산을 완료할 간단한 방법은 존재하지 않는다; 우리는 단순히 앞서는 1을 무시하지 못한다. 기대되는 답은 -144인데, 이는 보이는 것과는 다르게 아주 잘못된 것은 아니다; 856은 144의 10의 보수인 것이다. 이 문제는 몇 가지 방법으로 다뤄질 수 있다.</p>
      <ul>
        <li>문제 자체를 무시한다. 만약 한 사람이 음수를 지원하지 않는 계산 장치를 가동하고 있다면 이것은 타당하다. 왜냐하면 계산 전에 두 피연산자를 비교해 두 피연산자가 올바른 순서로 입력되도록 하고, 그 결과가 타당함을 확인하는 것은 인간에게 쉬운 일이기 때문이다.</li>
        <li>같은 방법을 사용하여 856을 1000에서 빼고, 결과에 -를 단다.</li>
        <li>음수를 자신의 양수 상대의 기수 보수로 표현한다. (역자주: -3이면 3으로 표현한다는 뜻인 듯) b<sup>n</sup> / 2 보다 작은 수는 양수로 간주된다; 나머지는 음수로 간주된다 (그리고 그 규모는 기수 보수를 취함에 의해 얻어질 수 있다). 이 방법은 짝수 기수에 대해 가장 잘 작동한다. 왜냐하면 부호가 첫번째 숫자를 봄으로써 결정될 수 있기 때문이다. 예를 들어, 10의 보수 표기법에서의 숫자들은 만약 첫번째 숫자가 0,1,2,3,4면 양수고 5,6,7,8,9면 음수이다. 그리고 이것은 이진에서 아주 잘 작동하는데 그 이유는 첫번째 비트가 부호 비트로 간주될 수 있기 때문이다: 만약 부호 비트가 0이면 숫자는 양수고 부호 비트가 1이면 숫자는 음수이다. 실제로, 2의 보수는 대부분의 현대 컴퓨터에서 사용되어 부호 있는 수를 표현한다.</li>
        <li>만약 최상위 숫자에서 carry가 발생하지 않았다면 (이는 x가 y보다 작다는 표시이다) 결과를 보완한다. 이것은 피연산자를 비교하고 위치를 바꾸는 것보다 디지털 회로에서 구현하기 더 쉽다. 하지만 기수 보수를 취하는 것은 1을 더하는 것을 필요로 하기 때문에, 직접적으로 하기엔 어렵다. 다행스럽게도, 이 덧셈을 피하기 위해 트릭이 사용될 수 있다: 빼기를 할 때 항상 최하위 숫자부터 carry를 시작하는 것 대신에, 최상위 숫자에서의 carry가 최하위 숫자에 입력되는 carry로 사용된다 (이 연산은 end-around carry라고 불린다). 그래서 만약에 y ≤ x 라면, 보통은 무시될 최상위 숫자로부터의 carry가 더해지며, 올바른 결과를 생산한다. 그리고 만약 y ≤ x 가 아니라면, 그 1은 더해지지 않고 결과는 답의 기수 보수보다 하나 작거나, 혹은 감기수 보수인데, 감기수 보수는 답을 얻기 위해 덧셈을 요구하지 않는다. 이 방법은 부호 있는 숫자를 표현하기 위해 sign-and-magnitude를 사용하는 컴퓨터에서 사용된다.
          <p>※ end-around carry: 윤회식 자리올림; 컴퓨터로 가감승제를 통해 숫자들을 연산할 때 최대 유효수 자리에서 최하의 자릿수로 옮겨지는 올림수 (출처: 네이버 백과사전) / 유사단어로 보이는 것: end-around borrow: 순환 자리 빌림</p>
        </li>
      </ul>
    </section>
    <section>
      <h2 id="실용적 사용">실용적 사용</h2>
      <p>보수법은 많은 기계식 계산기에서 기어를 반대 방향으로 돌리는 것(역자주: 무슨 뜻인지 잘 모르겠음)에 대한 대안으로 사용되었었다. 예를 들자면:</p>
      <ul>
        <li>파스칼의 계산기는 두 세트의 결과 숫자들을 가지는데, 검은 세트는 일반 결과를 표시하고 붉은 세트는 결과의 9들의 보수를 표시한다. 가로로 된 조각이 사용되어 이 세트 중 하나를 가리고, 다른 것을 노출시켰다. 뺄셈을 하기 위해서, 붉은 숫자들은 노출되었고 0으로 설정되었다. 그리고서 피감수의 9들의 보수가 입력되었다. 몇몇 기계에서 이 작업은 보수들의 내부 핸들을 사용하여 피감수를 dial함으로써 이루어졌다 (즉 암산으로 피감수의 9들의 보수를 결정할 필요 없이). 그 데이터를 보수 윈도우 (붉은 세트) 에 표시함으로써, 조작하는 사람은 피감수의 9들의 보수의 9들의 보수를 볼 수 있었는데, 이것은 피감수 그 자체이다. 앞서 말한 가로로 된 조각은 그리고 나서 이동되어 검은 숫자들을 노출시키고 (이 숫자들은 이제 피감수의 9들의 보수를 표시했다) 감수가 dial됨으로써 추가되었다. 마지막으로, 조작하는 사람은 가로로 된 조각을 다시 움직여 올바른 답을 읽어야 했다.</li>
        <li>고속도 계산기(comptometer)는 각 키에 일반 숫자들을 따라 작은 활자로 인쇄된 9의 보수 숫자들을 가진다. 뺄셈을 하기 위해서, 조작자는 사람은 감수에서 1을 암산으로 빼고 그 결과를 작은 숫자들을 이용해 입력하기가 기대되었다. 보완하기 전에 1을 빼는 것은 후에 1을 더하는 것과 같으므로, 조작자는 따라서 효과적으로 감수의 10의 보수를 추가하였다. 조작자는 또한 답의 가장 왼쪽에 있는 숫자에 일치하는 "뺄셈 잘라내기 탭" 을 누르고 있을 필요가 있었다. 이 탭은 carry가 그것을 지나 전파되는 것을 방지하였는데, 이는 결과에서 맨 앞의 1을 탈락시키는 고속도 계산기의 방법이었다.</li>
        <li>Curta 계산기는 보수법을 뺄셈에 사용하였고, 이것을 사용자로부터 숨기려고 노력하였다. 숫자들은 장치의 측면을 따라 있는 숫자 입력 슬라이드를 사용하여 입력되었다. 각 슬라이드의 숫자는 회전하는 "echelon drum" (다른 말로는 "step drum") 위에 있는 cam들을 맞물리게 하는 gearing 메커니즘에 의해 결과 카운터에 추가되었다. 이 drum은 장치의 위에 있는 crank의 사용에 의해 회전되었다. crank가 회전되며 각 자리에 의해 접하는 cam들의 숫자는 각 자리의 값에 의해 결정되었다. 예를 들어, 만약 슬라이드가 "6" 위치에 설정되었다면, 6 cam들의 열이 그 위치에 일치하는 drum 주위에서 만나게 된다. 뺄셈에 대해서는, drum이 회전되기 전에 살짝 이동되었고, 이는 각기 다른 cam들의 열을 제자리로 움직였다. 이 번갈아 나오는 열은 숫자들의 9들의 보수를 포함한다. 따라서, 덧셈을 위해 자리에 있던 6 cam들의 열은 이제 3 cam들을 가진 열을 가진다. 옮겨진 drum은 또한 결과에 1을 더하는 하나의 추가적인 cam을 맞물리게 한다 (이는 보수법에 의해 요구된다). 결과 레지스터의 최상위 숫자 너머로 carry된 항상 존재하는 10의 보수 "오버플로우 1"은, 효과적으로, 폐기된다.</li>
      </ul>
      <h3 id="컴퓨터에서">컴퓨터에서</h3>
      <p>보수법의 사용은, 부호 있는 수에 사용되는 표현법에 상관없이, 디지털 컴퓨터에서 아주 흔하다. 그러나, 요구되는 회로는 표현법에 따라 다르다:</p>
      <ul>
        <li>만약 2의 보수 표현법이 사용된다면, 뺄셈은 오직 감수의 비트를 전환하고 가장 오른쪽에 있는 비트에 carry를 설정하는 것만을 요구한다.</li>
        <li>1들의 보수 표현법을 사용하는 것은 감수의 비트를 전환하고 최상위 비트로부터의 carry를 최하위 비트의 carry로 연결시키는 것 (end-around carry) 을 요구한다.</li>
        <li>sign-magnitude 표현법을 사용하는 것은 오직 감수의 부호 비트를 보완하고 더하는 것마을 요구하나, 덧셈/뺄셈 로직은 부호 비트를 비교하고, 만약 입력이 다르다면 입력 중 하나를 보완하고, end-around carry를 구현하고, 만약 최상위 비트로부터의 carry가 없다면 결과를 보완하는 것을 필요로 한다.</li>
      </ul>
      <h3 id="직접 사용하기">직접 사용하기</h3>
      <p>보수법은 회계 장부가 손으로 쓰여져 있을 때 오류를 정정하기 위해 사용된다. 숫자들의 행으로부터 입력을 제거하기 위해서, 회계사는 뺄 숫자의 10의 보수를 가진 새로운 입력을 추가할 수 있다. 이 입력의 숫자들 위로 줄이 추가되어 이것의 특별한 상태를 나타낸다. 그리고 나서 figure들의 전체 행을 더해 정정된 결과를 얻는 것이 가능하다.</p>
      <p>합을 보완하는 것은 출납원이 통화의 base의 정수 배에 상승된 1의 하나의 액면가에서의 통화로부터의 구매에 대한 변화를 만드는 것에 유용하다. (역자주: 무슨 말인지 전혀 모르겠음) 10진법 통화에 대해서, 이것은 10, 100, 1000 등이 될 것이다. 예: $10.00 지폐.</p>
    </section>
    <section>
      <h2 id="초등학교 교육에서">초등학교 교육에서</h2>
      <p>초등학교에서, 학생들은 때때로 암산에 유용한 방법으로 보수법을 배운다. 뺄셈은 감수의 10의 보수를 더함으로써 이루어지는데, 이는 9들의 보수 더하기 1이다. 이 덧셈의 결과는 차이가 양수일 때 확실하지만, 그렇지 않을 경우 덧셈의 결과의 10의 보수는 음수로 마킹된 채로 사용된다. 같은 기법이 덧셈 기계에서의 뺄셈에서도 작동한다.</p>
    </section>
  </body>
</html>